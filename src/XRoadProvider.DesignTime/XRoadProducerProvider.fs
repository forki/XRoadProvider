namespace ProviderImplementation.ProvidedTypes

open FSharp.Core.CompilerServices
open FSharp.Quotations
open System
open System.IO
open System.Collections.Concurrent
open System.Reflection
open XRoad

/// Generated type providers for X-Road infrastructure.
/// Currently only one type provider is available, which builds service interface for certain producer.
[<TypeProvider>]
type XRoadProducerProvider() as this =
    let invalidation = Event<_,_>()

    let namespaceName = "XRoad.Providers"
    let theAssembly = this.GetType().Assembly

    // Already generated assemblies
    let typeCache = ConcurrentDictionary<_, Type>()

    // Available parameters to use for configuring type provider instance
    let staticParameters =
        [ ProvidedStaticParameter("ProducerUri", typeof<string>), "WSDL document location (either local file or network resource)."
          ProvidedStaticParameter("LanguageCode", typeof<string>, "et"), "Specify language code that is extracted as documentation tooltips. Default value is estonian (et)." ]
        |> List.map (fun (parameter, doc) -> parameter.AddXmlDoc(doc); parameter :> ParameterInfo)
        |> List.toArray

    interface ITypeProvider with
        /// Called when type alias is created, generates assembly for given arguments.
        override __.ApplyStaticArguments(typeWithoutArguments, typeNameWithArguments, staticArguments) =
            match typeWithoutArguments with
            | :? ProvidedTypeDefinition ->
                let producerUri = unbox<string> staticArguments.[0]
                let languageCode = unbox<string> staticArguments.[1]

                // Same parameter set should have same output, so caching is reasonable.
                let key = (String.Join(".", typeNameWithArguments), producerUri, languageCode)
                typeCache.GetOrAdd(key, (fun key -> ProducerDefinition.makeProducerType(typeNameWithArguments, producerUri, languageCode)))
            | _ -> failwith "not implemented"

        /// Returns contents of assembly generated by type provider instance.
        override __.GetGeneratedAssemblyContents(assembly) =
            File.ReadAllBytes(assembly.ManifestModule.FullyQualifiedName)

        /// Generated types need to handle only instantiation and method call expressions, others are not used.
        override __.GetInvokerExpression(syntheticMethodBase, parameters) =
            let parameters = parameters |> List.ofArray
            match syntheticMethodBase with
            | :? ConstructorInfo as ctor -> Expr.NewObject(ctor, parameters)
            | :? MethodInfo as mi when mi.IsStatic -> Expr.Call(mi, parameters)
            | :? MethodInfo as mi -> Expr.Call(parameters.Head, mi, parameters.Tail)
            | _ -> failwith "not implemented"

        /// Namespaces provided by this type provider instance.
        override __.GetNamespaces() = [| this |]

        /// Exactly one type can have static parameters with current implementation.
        override __.GetStaticParameters(typeWithoutArguments) =
            match typeWithoutArguments with
            | :? ProvidedTypeDefinition as ty when ty.Name = typeWithoutArguments.Name -> staticParameters
            | _ -> [| |]

        /// Default implementation for invalidation event.
        [<CLIEvent>]
        override __.Invalidate = invalidation.Publish

        /// No unmanaged resources to deallocate.
        override __.Dispose() = ()

    interface IProvidedNamespace with
        /// No nested namespaces defined.
        override __.GetNestedNamespaces() = [| |]

        /// Type provider contains exactly one abstract type which allows access to type provider functionality.
        override __.GetTypes() =
            let producerType = ProvidedTypeDefinition(theAssembly, namespaceName, "XRoadProducer", Some(typeof<obj>), isErased=false)
            producerType.AddXmlDoc("Type provider for generating service interfaces and data types for specific X-Road producer.")
            [| producerType |]

        /// Use default namespace for type provider namespace.
        override __.NamespaceName with get() = namespaceName

        /// No types have to be resolved.
        override __.ResolveTypeName(_) = null
